from astropy.io import fits
import matplotlib.pyplot as plt
import numpy as np

# Path to your FITS file (update this to your actual file path)
fits_path = "hlsp_frontier_model_abell370_cats_v4_kappa.fits"

# Load FITS file
hdul = fits.open(fits_path)
hdul.info()

# Usually the mass map is in the primary HDU or first extension
mass_map = hdul[0].data  # or try hdul[1].data if needed

# Close the FITS file after reading
hdul.close()

# Check shape and some stats
print("Mass map shape:", mass_map.shape)
print("Mass map stats - min:", np.min(mass_map), "max:", np.max(mass_map))

# Plot the convergence/mass map
plt.figure(figsize=(8, 6))
plt.imshow(mass_map, origin='lower', cmap='inferno')
plt.colorbar(label='Mass Density / Convergence (κ)')
plt.title('Galaxy Cluster Mass Map from FITS')
plt.xlabel('Pixel X')
plt.ylabel('Pixel Y')
plt.show()








pip install numpy matplotlib astropy scipy




import numpy as np
import matplotlib.pyplot as plt
from astropy.io import fits
from scipy.fft import fft2, ifft2, fftshift, ifftshift

# Load the convergence map (κ) from FITS file
filename = "hlsp_frontier_model_abell370_cats_v4_kappa.fits"
hdul = fits.open(filename)
kappa = hdul[0].data
hdul.close()

# Fourier space grid
ny, nx = kappa.shape
lx = np.fft.fftfreq(nx).reshape(1, nx)  # normalized freq x
ly = np.fft.fftfreq(ny).reshape(ny, 1)  # normalized freq y

# Wavevector squared
k_squared = (lx**2 + ly**2)
k_squared[0,0] = 1  # avoid divide by zero for DC term

# Fourier transform of convergence

kappa_ft = fft2(kappa)

# Compute deflection angle components in Fourier space:
# alpha_hat_x = -2i kx / k^2 * kappa_hat
# alpha_hat_y = -2i ky / k^2 * kappa_hat
factor = -2j / k_squared
alpha_x_ft = factor * lx * kappa_ft
alpha_y_ft = factor * ly * kappa_ft

# Transform back to real space deflection angles
alpha_x = np.real(ifft2(alpha_x_ft))
alpha_y = np.real(ifft2(alpha_y_ft))

# Visualize deflection angles
plt.figure(figsize=(10,10))
plt.quiver(alpha_x[::20, ::20], alpha_y[::20, ::20])
plt.title("Deflection Angles from Convergence Map (Sampled every 20 pixels)")
plt.xlabel("Pixel X")
plt.ylabel("Pixel Y")
plt.show()



# Assume nx, ny same as kappa shape
nx, ny = kappa.shape

# Define image plane grid (theta_x, theta_y)
theta_x, theta_y = np.meshgrid(np.arange(nx), np.arange(ny))

# Deflection angles already computed: alpha_x, alpha_y

# Compute source plane coordinates (beta_x, beta_y)
beta_x = theta_x - alpha_x
beta_y = theta_y - alpha_y

# For visualization, plot how a grid would map to the source plane
plt.figure(figsize=(10,10))
plt.scatter(beta_x[::50, ::50], beta_y[::50, ::50], s=1, color='blue')
plt.title("Mapped Source Plane Coordinates (Sampled Every 50 Pixels)")
plt.xlabel("Beta X")
plt.ylabel("Beta Y")
plt.gca().invert_yaxis()
plt.show()


import numpy as np
import matplotlib.pyplot as plt

# Image size (should match your mapping arrays)
img_size = 3000

# Create a Gaussian source in the center of the source plane
x = np.arange(img_size)
y = np.arange(img_size)
xx, yy = np.meshgrid(x, y)
# Center and width of source
cx, cy = img_size // 2, img_size // 2
sigma = 100  # Size of the galaxy

# 2D Gaussian
source_img = np.exp(-((xx-cx)**2 + (yy-cy)**2) / (2 * sigma**2))


# Ensure beta_x and beta_y are integer indices within the image bounds
beta_x_clip = np.clip(beta_x.astype(int), 0, img_size-1)
beta_y_clip = np.clip(beta_y.astype(int), 0, img_size-1)

# Create lensed image: each (i, j) pixel in the image plane takes its value from the mapped source coordinates
lensed_img = source_img[beta_y_clip, beta_x_clip]

# Display the result
plt.figure(figsize=(8, 8))
plt.imshow(lensed_img, origin='lower', cmap='afmhot')
plt.title('MBT Simulated Gravitational Lensing (Lensed Gaussian Source)')
plt.xlabel('Pixel X')
plt.ylabel('Pixel Y')
plt.colorbar(label='Intensity')
plt.tight_layout()
plt.show()
